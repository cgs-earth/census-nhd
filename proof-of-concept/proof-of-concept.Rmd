---
title: "Census-NHD Proof-of-concept"
author: 
- Kyle Onda^[konda@lincolninst.edu]
date: "`r Sys.Date()`"
output:   
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    code_folding: hide
    fig_width: 8
    fig_height: 8
    theme: readable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(sf)
library(tidycensus)
library(tigris)
library(nhdplusTools)
library(mapview)
census_api_key("b25f8b1b7bf10561c9cbc3a20a4d2572677f1f05")
options(tigris_use_cache = TRUE)
```

## Download NHD Data

Here, we download NHDPlusV2.1, extract the Catchment polygons, and clip to the set of catchments that intersect HUC4 0303 (Cape Fear). For display purposes we just show the Catchments in Orange County, NC, overlayed with the intersecting HUC12 to show the relative size disparity.

```{r nhd, results="asis"}
hu04 <- sf::read_sf("https://geoconnex.us/ref/hu04/0303") %>% st_transform(4326)
# download_nhdplusv2(outdir="./data/nhd/",
#                       url = paste0("https://s3.amazonaws.com/edap-nhdplus/NHDPlusV21/",
#     "Data/NationalData/NHDPlusV21_NationalData_Seamless", "_Geodatabase_Lower48_07.7z"),
#   progress = TRUE
# )
# 
# 
# path <- "./data/nhd/NHDPlusV21_National_Seamless_Flattened_Lower48.gdb"
# cat<- sf::st_read(path, layer = "Catchment") %>% st_transform(4326)
# 
sf_use_s2(FALSE)
# cat <- cat[hu04,]
# 
# write_sf(cat,"./data/staged/catchments.gpkg")
# huc12 <- sf::read_sf("./data/nhd/WbDHU12.shp") %>% st_transform(4326)
# huc12 <- huc12[hu04,]


cat <- read_sf("./data/staged/catchments.gpkg")
orange_county <- sf::read_sf("https://geoconnex.us/ref/counties/37135")
# catchments_orange <- cat[orange_county,]
# huc12 <- huc12[orange_county,]
# sf::write_sf(huc12,"./data/staged/huc12.gpkg")

huc12 <- read_sf("./data/staged/huc12.gpkg")


# path <- "./data/nhd/NHDPLUS_H_0303_HU4_GDB.gdb"
# cathr<- sf::st_read(path, layer = "NHDPlusCatchment",int64_as_string=TRUE) %>% st_transform(4326)
# cathr_orange <- cathr[orange_county,]
# flowhr<-sf::st_read(path, layer = "NHDFlowline") %>% st_transform(4326) %>% st_zm()
# flowhr <- flowhr[orange_county,]
# 
# sf::write_sf(cathr_orange,"./data/staged/cathr_orange.gpkg")
# sf::write_sf(flowhr,"./data/staged/flowhr.gpkg")

cathr_orange <- read_sf("./data/staged/cathr_orange.gpkg")
flowhr <- read_sf("./data/staged/flowhr.gpkg")

map <- mapview(cathr_orange, alpha.regions=0, color="darkgreen", layer.name="Catchments", col.regions="darkgreen") +
  mapview(huc12, alpha.regions=0, color="brown", col.regions="brown", lwd=2,layer.name="HUC12") + 
  mapview(flowhr, color="blue", layer.name="Flowlines")

map
```
## Download Census data

Here, we download census blocks, block groups, tracts, and counties from the Census TIGER/LINE files. For comparison purposes, we just show Catchments, Census Blocks, and HUC12s to show the utility doing this.

```{r census, results="asis"}
#  counties <- counties(state = 37) %>% st_transform(4326)
#  blocks <- blocks(state = 37, year = 2020) %>% st_transform(4326)
#  tracts <- tracts(state = 37, year = 2020) %>% st_transform(4326)
#  block_groups <- block_groups(state = 37, year = 2020) %>% st_transform(4326)
#  tracts_0303 <- tracts[hu04,]
#  blocks_0303 <- blocks[hu04,]
#  counties_0303 <- counties[hu04,]
#  block_groups_0303 <- block_groups[hu04,]
# # 
#  write_sf(blocks_0303,"./data/staged/blocks.gpkg")
#  write_sf(counties_0303,"./data/staged/counties.gpkg")
#  write_sf(block_groups_0303,"./data/staged/block_groups.gpkg")
#  write_sf(tracts_0303,"./data/staged/tracts.gpkg")

blocks <- read_sf("./data/staged/blocks.gpkg")
block_groups <- read_sf("./data/staged/block_groups.gpkg")
tracts <- read_sf("./data/staged/tracts.gpkg")
counties <- read_sf("./data/staged/counties.gpkg")

blocks_orange <- blocks[orange_county,]

#mapview(counties, col.regions="red", alpha.regions=0.2) + 
#  mapview(tracts, col.regions="orange", alpha.regions=0.2) + 
 # mapview(block_groups, col.regions="green", alpha.regions=0.2)# + 

 map + mapview(blocks_orange, alpha.regions=0, color="black", col.regions="black", lwd=0.3)

```

## Intersection

We attempt to intersect blocks and catchments. First we ensure we are using valid spherical geometries, and calculate the areas of both. In Orange County within HUC4 0303, $6,468$ of these result from $1,544$ Census Blocks and $1,826$ NHDPlusHR Catchments. The histogram below visualizes the distribution of Census 2020 Block/ NHDPlusHR Catchment intersection polygons according to the proportion of the area of the Block that is in the intersection polygon. This shows why using an intersection method is important, and not using simplifications such as assigning Blocks to Catchments based on centroid-in-polygon type methods. While $50\%$ of blocks in this sample are completely or $>99\%$ within one NHDHR Catchment, $46\%$ of blocks are between $20\%$ and $80\%$ overlapping with 1 or more NHDHR Catchments .

```{r intersection, results="asis"}
# sf_use_s2(FALSE)
# cathr_orange <- st_make_valid(cathr_orange)
# blocks_orange <- st_make_valid(blocks_orange)
# cathr_orange$area_catchment_m2 <- st_area(cathr_orange)
# blocks_orange$area_block_m2 <- st_area(blocks_orange)
# cross <- st_intersection(cathr_orange,blocks_orange)
# cross$area_cross_m2 <- st_area(cross)
# cross$prop_block_in_catchment <- as.numeric(cross$area_cross_m2/cross$area_block_m2)
# cross$prop_catchment_in_block<- as.numeric(cross$area_cross_m2/cross$area_catchment_m2)
# write_sf(cross,"./data/staged/cross.gpkg")

cross <- read_sf("./data/staged/cross.gpkg")

cross_summary <- cross %>% 
  group_by(GEOID20) %>%
  mutate(max_cross = max(prop_block_in_catchment)) %>%
  ungroup() %>% 
  filter(max_cross == prop_block_in_catchment)

hist(cross_summary$prop_block_in_catchment, freq = FALSE)


```

## Summarizing Census Data

Broadly, there are two types of census data variables made available at any given census geography:

* counts (e.g. of people/households of various ages/genders/races/income brackets)
* summary statistics of distributions (e.g. median household income)

Since Census Blocks are the smallest spatial units for which census data is available, if estimates of census variables are to be made for areas that represent aggregates of *parts* of blocks, an assumption must be made as to how to distribute the measured variable among those parts. A reasonable, if imperfect, assumption is to assume that all populations that are 
counted are dispersed evenly spatially throughout the block. This results in different calculations for aggregating Census Block counts vs summary statistics across 1 or more Census Block parts. 

Consider the simplest variable available: Total Population (residing in a Census Block). If one were to divide a Census Block into two parts each with $1/2$ the area of Block, this assumption would imply that each part would have $1/2$ of the Total Population. 

```{r census_data}

```


## Areal Weigting Scheme

The key to calculating

